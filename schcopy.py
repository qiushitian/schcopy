#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on 2023 06 23

IMPORTANT NOTICE
-----
Code here might be generated by ChatGPT
and might yet to be tested by human

@author: Qiushi (Chris) Tian

Last edit: 2023 06 28
"""

# Target (MUST BE SEPERATED WITH SPACE)
TARGET = 'HD 86226'

# Define the directory where the FITS files are located
SRC_PATH = Path(r"D:\Images\Scheduler\Kyle McGregor")
# SRC_PATH = r"D:\chris-tian\copy-folder-test"

# the file that contains the list of targets
# TARGET_LIST_PATH = r'hd191939.txt' # r'space_targets.txt'

# Define the path for the copied FITS files
DEST_PATH = Path(r"\\tsclient\mountpoint\space-raw")
# DEST_PATH = r"\\tsclient\mountpoint\copy-folder-test"

# path for robocopy logs
LOG_PATH = Path(r"D:\chris-tian\copy-folder-log")

# size of single FITS file
FILE_SIZE = 8395200 # byte

import os
import subprocess
from pathlib import Path
from datetime import datetime

def is_target(observed_object, target):
    '''
    '''
    if all(word.casefold() in observed_object.casefold() for word in target.split()):
        return True

def shutil_copy(src, dest, *args, copytree_func=copyfile, bufsize=None):
    pass

def robocopy(src, dest, mt=8):
    pass

def copy(src, dest, copyfunc=shutil_copy, *args):
    copyfunc(src, dest, *args)

def read_log():
    pass

def write_log():
    pass

# def is_target_from_file(file_path, observed_object):
#     '''
#     Check if the observed object is one of our targets.
#
#     Parameters
#     ----------
#     file_path : str
#         Dir of target list.
#     observed_object : str
#         Name of observed object.
#
#     Returns
#     -------
#     bool
#         DESCRIPTION.
#
#     '''
#     with open(file_path) as f:
#         for line in f:
#             words = line.strip().replace('-', ' ').replace('/', ' ').replace('_', ' ').split()
#             if all(word.casefold() in observed_object.casefold() for word in words):
#                 return True
#     return False

if __name__ == '__main__':
    today = int(datetime.now().strftime('%Y%m%d'))
    target_dash = TARGET.replace(' ', '-')

    dates = set()
    nfile = 0

    # TODO read log and skip already copied
    # with read_log and write_log

    # create
    # what is that?

    # TODO os.scandir os.listdir Path.iterdir??

    # loop through date-named subdirs
    for date_entry in os.scandir(SRC_PATH):
        # skip non-folders
        if not date_entry.is_dir():
            continue

        # VARIBLE date string
        date = date_entry.name

        # skip non-date folders
        if not date.startswith('20'):
            continue

        # skip (potentially) current night of data
        if int(date) >= today - 1:
            continue

        # loop through targets of the day
        for target_entry in os.scandir(date_entry.path):
            # skip non-folders
            if not target_entry.is_dir():
                continue

            target = target_entry.name
            target_path = target_entry.path

            # skip non-targets folders
            if not is_target(target, TARGET):
                continue

            # record date of file being copied
            dates.add(date)

            # number of files
            n = len(os.listdir(target_path))
            if n < 1: # skip emplty dir
                continue
            nfile += n

            # COPYING BLOCK

            # make dir
            mdcmd = ['md', os.path.join(DEST_PATH, date)]
            mdproc = subprocess.run(mdcmd, shell=True)
            print(f'md {mdcmd[1]} returns {mdproc.returncode}')
            print(mdproc.stdout)
            print(mdproc.stderr)

            # copy
            robocmd = ['robocopy',
                        target_path,
                        os.path.join(DEST_PATH, date, target_dash),
                        r'/S', r'/DCOPY:EDT', r'/COPY:DTSO',
                        r'/R:0', r'/W:0',
                        fr'/LOG+:{LOG_PATH}\robocopy_{today}_{target_dash}.log']
            roboproc = subprocess.run(robocmd, shell=True)
            print(f'robocopy returns {roboproc.returncode}')
            print(roboproc.stdout)
            print(roboproc.stderr)

            # handling robocopy error
            if roboproc.returncode >= 8:
                print('\n********** robocopy error **********')
                # print(robocmd)
                # print(f'Return code = {roboproc.returncode}')
                print(roboproc.stdout)
                print(roboproc.stderr)
                print()
                raise subprocess.CalledProcessError(roboproc.returncode, robocmd)

            # if success, echo
            print('Copied', target_path)

            # END of COPYING BLOCK

    # sort dates
    sorted_dates = sorted(dates)

    # TODO add creating file header

    # write file
    with open(os.path.join(LOG_PATH, f'schcopy_{target_dash}.log'), mode='a') as f:
        f.writelines(date + '\n' for date in sorted_dates[:-1])
        f.write(f'{sorted_dates[-1]} {today} {nfile}\n')

    # get total size
    total_size = [nfile * FILE_SIZE / 1024 / 1024 / 1024, 'GB']
    if total_size[0] < 1:
        total_size[0] *= 1024
        total_size[1] = 'MB'

    # print result stat
    print('\n---------------- Run Conluded ----------------')
    print('Dates copied:', sorted_dates)
    print(f'{nfile} file(s) copied, estimated to be {total_size}')

                    # CANCELED copy foler, not loop through files
                    # with os.scandir(target_entry.path) as file_iterator:
                    #     for file_entry in file_iterator:
                    #         # skip non-files
                    #         if not file_entry.is_file():
                    #             continue
                    #
                    #         # VARIBLE file name
                    #         filename = file_entry.name
                    #
                    #         # skip non-FITS files
                    #         if not filename.casefold().endswith((".fit", ".fits", ".fts")):
                    #             continue
                    #
                    #         # VARIBLE file path
                    #         file_path = file_entry.path
                    #
                    #         # Open the FITS file and read the header
                    #         try:
                    #             with fits.open(file_path) as hdul:
                    #                 header = hdul[0].header
                    #                 date_obs = header['DATE-OBS']
                    #                 object_name = header['OBJECT']
                    #                 jd = header['JD']
                    #                 filt = header['FILTER']
                    #                 airmass = header['AIRMASS']
                    #                 skytemp = header['SKYTEMP']
                    #                 windspd = header['WINDSPD']
                    #                 #dewpoint = header['DEWPOINT']
                    #                 exptime = header['EXPTIME']
                    #         except KeyError:
                    #             print(f"{file_path} header missing necessary key(s): 'DATE-OBS', 'OBJECT', 'JD', 'FILTER', 'AIRMASS', 'SKYTEMP', 'WINDSPD', 'EXPTIME'.")
                    #             continue

##### FROM chriscessor.py ####
    #
    #             # Construct the new file name with the DATE-OBS value prepended to the original file name
    #             new_file_path = os.path.join(DEST_PATH, date_folder_name, filename)
    #
    #             # Copy the file to the DEST_PATH directory
    #             os.makedirs(os.path.dirname(new_file_path), exist_ok=True)
    #             ### debug ###
    #             print(f'copy to "{new_file_path}"')
    #             # break
    #             ### debug ###
    #             os.system(f'copy "{file_path}" "{new_file_path}"')
    #
    #             # Store the information in a dictionary
    #             info_dict = {
    #                 'object': object_name,
    #                 'date-obs': date_obs,
    #                 'jd': jd,
    #                 'filter': filt,
    #                 'airmass': airmass,
    #                 'skytemp': skytemp,
    #                 'windspd': windspd,
    #                 'exptime': exptime
    #             }
    #
    #             # Append the dictionary to the list in the object_dict
    #             if object_name in object_dict:
    #                 object_dict[object_name].append(info_dict)
    #             else:
    #                 object_dict[object_name] = [info_dict]
    #
    # # Loop through the keys in the object_dict and write a separate CSV for each object
    # for object_name in object_dict:
    #     # Define the path for the CSV file
    #     csv_path = os.path.join(DEST_PATH, f"{object_name.replace('/', '-')}_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.csv")
    #
    #     # Write the CSV file
    #     with open(csv_path, mode='w', newline='') as csv_file:
    #         fieldnames = ['object', 'date-obs', 'jd', 'filter', 'airmass', 'skytemp', 'windspd', 'exptime']
    #         writer = csv.DictWriter(csv_file, fieldnames=fieldnames)
    #
    #         # Write the header row
    #         writer.writeheader()
    #
    #         # loop around and write body row
    #         for row in object_dict[object_name]:
    #             writer.writerow(row)
